;################################################################################################
;Name: 							Program:	@filesorta					Due: 	
;Contract:						Course:		CSCI 220					Prof:	John Broere
;
;Description:
;
;
;################################################################################################

;(trace @eval @second @third + - * /) ; remove comment to use trace

;*************************************************************************************
; @filesorta | The basic loop that receives input from a file, and then prints out to
;	another file the results of that input.
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;
;Special Thanks to:
;
;
;Pre: A file "test.in" exists, in the current directory, with valid test data.
;Post: Input line printed to the file "test.out", value generated by (@eval now)
;	printed to that file; "quit" has been read from input file.
;`````````````````````````````````````````````````````````````````````````````````````
(setf assocList NIL)

(defun @filesorta (&optional (fileNameIN "test.in") (fileNameOUT "test.out"))
	
	(setq fp_in (open fileNameIN :direction :input))
	(setq fp_out (open fileNameOUT :direction :output))

	(cond
		((equal fp_in NIL)  (return 'open_input_failed))
		((equal fp_out NIL) (return 'open_output_failed))
	)
	
	(princ "[" fp_out)
	(princ fileNameOUT fp_out)
	(princ "] was created using [" fp_out)
	(princ fileNameIN fp_out)
	(princ "]\n\n" fp_out)
	
	(loop
		(setf now (read fp_in))
		(print now fp_out)

		(cond
			((equal now 'quit)  	(close fp_in) (close fp_out) (return 'DONE))
			(T						(print (@eval now) fp_out))	
		)
		
		(princ "\n" fp_out)
	)
	(exit)
)

;*************************************************************************************
;@eval | 
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;
;Special Thanks to:
;
;pre:
;post:
;`````````````````````````````````````````````````````````````````````````````````````

;(defun @eval (elist)
;	(cond
;        ((numberp elist)      elist)
;        ((atom elist)	(@find elist))
;        ((equal (first elist) '+)     (+ (@eval (@second elist)) (@eval (@third elist))))
;        ((equal (first elist) '-)     (- (@eval (@second elist)) (@eval (@third elist))))
;        ((equal (first elist) '*)     (* (@eval (@second elist)) (@eval (@third elist))))
;        ((equal (first elist) '/)     (/ (@eval (@second elist)) (@eval (@third elist))))
;        ((equal (first elist) '==)     (= (@eval (@second elist)) (@eval (@third elist))))
;        ((equal (first elist) '<)     (< (@eval (@second elist)) (@eval (@third elist))))
;        ;((equal (first elist) '>)     (> (@eval (@second elist)) (@eval (@third elist))))
;    )
;)

(defun @eval (elist)
    (cond
        ((numberp elist)      elist)
        ((atom elist)   (@find elist))
        ((equal (first elist) '+)     (+ (@eval (@second elist)) (@eval (@third elist))))
        ((equal (first elist) '-)     (- (@eval (@second elist)) (@eval (@third elist))))
        ((equal (first elist) '*)     (* (@eval (@second elist)) (@eval (@third elist))))
        ((equal (first elist) '/)     (/ (@eval (@second elist)) (@eval (@third elist))))
        ((equal (first elist) '==)    (= (@eval (@second elist)) (@eval (@third elist))))
        ((equal (first elist) '<)     (< (@eval (@second elist)) (@eval (@third elist))))
        ((equal (first elist) '>)     (@if(< (@eval (@second elist)) (@eval (@third elist))) NIL T))
    )
)


(defun @if ((cnd) (tru) (fls))
	(cond
		((@eval cnd) (@eval tru))
		(t 		(@eval fls))
	)
)

(defun @while ((cnd) (ins))
	(@if cnd (@while (cnd) (ins)) (return))
)

(defun @set (id data)
	(@if (@find id) )
	(cons (cons id data) assocList)
)

(defun @second (l)
	(first(rest l))
)

(defun @third (l)
	(first(rest(rest l)))
)

(defun @add (var val)
	(setf varList (cons(cons var val) varList)) ;magic happens in (cons var val)
)